import { createNoise3D, createNoise2D } from 'https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1/+esm';

document.addEventListener('DOMContentLoaded', () => {
    const textElement = document.querySelector('.text-preload');
    if (textElement) {
        requestAnimationFrame(() => {
            textElement.classList.add('text-loaded');
        });
    }

    const canvas = document.getElementById('automataCanvas');
    if (!canvas) {
        console.error('Canvas element not found!');
        return;
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error('2D context not available.');
        return;
    }

    const textContainerElement = document.querySelector('.text'); // Get the .text element
    let textZone = { x1: 0, y1: 0, x2: 0, y2: 0 }; // In grid coordinates

    let CELL_SIZE = 15;
    let gridWidth, gridHeight;
    let grid, nextGrid;

    let currentM, currentS, currentDT;
    let currentTextZoneSurvivalChance;

    const KERNEL_PRESETS = {
        "single_ring": { // Maze
            M: 0.39,
            S: 0.08,
            DT: 0.05,
            KERNEL_RADIUS: 3,
            TEXT_ZONE_SURVIVAL_CHANCE: 0.3,
            kernelParams: {
                rings: [
                    { radius: 0.5, width: 0.15, height: 1.0, sensitivity: 1, shape: "gaussian" }
                ]
            }
        },
        "triplebump": { // Organic wire
            M: 0.3,
            S: 0.032,
            DT: 0.05,
            KERNEL_RADIUS: 5,
            TEXT_ZONE_SURVIVAL_CHANCE: 0.8,
            kernelParams: {
                rings: [
                    { radius: 0.3, width: 0.3, height: 0.1, sensitivity: 1, shape: "gaussian" },
                    { radius: 0.6, width: 0.2, height: 0.4, sensitivity: 1, shape: "exponential" },
                    { radius: 0.85, width: 0.6, height: 0.8, sensitivity: 1, shape: "gaussian" }
                ]
            }
        },
        "central_peak": { // little guys
            M: 0.25,
            S: 0.03,
            DT: 0.04,
            KERNEL_RADIUS: 8,
            TEXT_ZONE_SURVIVAL_CHANCE: 0.4,
            kernelParams: {
                rings: [
                    { radius: 0.0, width: 0.1, height: 3.0, sensitivity: 2, shape: "gaussian" },
                    { radius: 0.7, width: 0.15, height: 0.5, sensitivity: 1, shape: "gaussian" }
                ]
            }
        },
        "triple_peak": { // blocky
            M: 0.25,
            S: 0.045 ,
            DT: 0.01,
            KERNEL_RADIUS: 3,
            TEXT_ZONE_SURVIVAL_CHANCE: 0.4,
            kernelParams: {
                rings: [
                    { radius: 0.0, width: 0.05, height: 1.5, sensitivity: -0.5, shape: "exponential" },
                ]
            }
        },
        "mixed_shapes": {
            M: 0.3,
            S: 0.08,
            DT: 0.03,
            KERNEL_RADIUS: 5,
            TEXT_ZONE_SURVIVAL_CHANCE: 0.9,
            kernelParams: {
                rings: [
                    { radius: 0.0, width: 0.1, height: 0.8, sensitivity: 1, shape: "gaussian" },
                    { radius: 0.4, width: 0.12, height: 1.2, sensitivity: 1, shape: "exponential" },
                    { radius: 0.7, width: 0.08, height: 0.4, sensitivity: 1, shape: "gaussian" }
                ]
            }
        },
    };

    const INTERACTION_RADIUS = 3;
    const availableKernelTypes = Object.keys(KERNEL_PRESETS);
    let SELECTED_KERNEL_TYPE = availableKernelTypes[Math.floor(Math.random() * availableKernelTypes.length)];

    // --- Wind Parameters ---
    const WIND_DIRECTIONS = [ // Possible directions for wind events {dx: change in x, dy: change in y}
        { dx: 1, dy: 0 },  // East
        { dx: -1, dy: 0 }, // West
        { dx: 0, dy: 1 },  // South
        { dx: 0, dy: -1 }  // North
    ];
    let currentWind = null; // Stores active wind: { dx, dy, strength, endTime }
    const WIND_STRENGTH = 0.005;            // Factor determining how much an upwind cell's value influences its downwind neighbor.
    const WIND_EVENT_MIN_INTERVAL = 100;  // Minimum time (ms) between the end of one wind event and the start of the next.
    const WIND_EVENT_MAX_INTERVAL = 200;  // Maximum time (ms) between the end of one wind event and the start of the next.
    const WIND_EVENT_MIN_DURATION = 500;  // Minimum duration (ms) a single wind event can last.
    const WIND_EVENT_MAX_DURATION = 1000; // Maximum duration (ms) a single wind event can last.
    let windTimeoutId = null;
    let kernel; // Convolution kernel matrix, generated by createKernel()
    let time = 0; // Time variable for animated Perlin noise

    // Initialize Perlin noise
    const backgroundNoise = createNoise3D(); // For the content of the text background
    const edgeNoise = createNoise3D();       // For animating ragged edges
    const noiseScale = 0.3; // feature size of Perlin noise for background
    const timeNoiseScale = 0.01; // speed of noise animation for background

    // Mouse interaction for text zone background
    let mouseEffectCenter = null;
    let lastMouseMoveInTextZoneTime = 0;
    const MOUSE_EFFECT_DURATION = 1000; // ms - How long the effect lasts after mouse stops
    const MOUSE_EFFECT_RADIUS = 6;   // grid cells - How far the effect spreads
    const MOUSE_EFFECT_SHIFT_MAGNITUDE = 7; // How much to shift noise time

    // Ragged edge parameters for text death zone
    const RAGGED_EDGE_PADDING = 10;        // How many cells around original textZone to check
    const RAGGED_EDGE_NOISE_SCALE = 0.2;  // Scale of noise for edge perturbation
    const RAGGED_EDGE_NOISE_MAGNITUDE = 2; // Max cell displacement for edge
    const RAGGED_EDGE_TIME_NOISE_SCALE = 0.01; // Speed of edge animation

    function updateActiveLeniaParams() {
        const preset = KERNEL_PRESETS[SELECTED_KERNEL_TYPE];
        if (!preset) {
            console.error(`Preset for kernel type ${SELECTED_KERNEL_TYPE} not found! Using defaults.`);
            currentM = 0.15;
            currentS = 0.015;
            currentDT = 0.1;
            currentTextZoneSurvivalChance = 0.9;
            return;
        }
        currentM = preset.M;
        currentS = preset.S;
        currentDT = preset.DT;
        currentTextZoneSurvivalChance = preset.TEXT_ZONE_SURVIVAL_CHANCE;
        console.log(`Activated Lenia params for ${SELECTED_KERNEL_TYPE}: M=${currentM}, S=${currentS}, DT=${currentDT}, K_RADIUS=${preset.KERNEL_RADIUS}, TZ_Survival=${currentTextZoneSurvivalChance}`);
    }

    function createKernel() {
        const preset = KERNEL_PRESETS[SELECTED_KERNEL_TYPE];
        const K_RADIUS = preset.KERNEL_RADIUS;
        const size = 2 * K_RADIUS + 1;
        kernel = Array(size).fill(null).map(() => Array(size).fill(0));
        let sum = 0;

        const { rings } = preset.kernelParams;

        for (let i = -K_RADIUS; i <= K_RADIUS; i++) {
            for (let j = -K_RADIUS; j <= K_RADIUS; j++) {
                const r = Math.sqrt(i * i + j * j) / K_RADIUS;
                let val = 0;
                
                for (const ring of rings) {
                    const { radius, width, height, sensitivity, shape } = ring;
                    const rFromRing = Math.abs(r - radius);
                    
                    if (shape === "gaussian") {
                        // Gaussian bell function centered at ring radius
                        val += height * Math.exp(-(rFromRing * rFromRing * sensitivity) / (2 * width * width));
                    } else if (shape === "exponential") {
                        // Exponential bell function centered at ring radius
                        val += height * Math.exp(-rFromRing * sensitivity / width);
                    }
                }
                
                kernel[i + K_RADIUS][j + K_RADIUS] = val;
                sum += val;
            }
        }

        // Normalize kernel
        if (sum !== 0) {
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    kernel[i][j] /= sum;
                }
            }
        } else {
            if (kernel[K_RADIUS] && kernel[K_RADIUS][K_RADIUS] !== undefined) {
                kernel[K_RADIUS][K_RADIUS] = 1;
                console.warn("Kernel sum was 0, fallback to center = 1. Check kernel parameters.");
            }
        }
    }

    function growthFunction(u) {
        return Math.exp(-((u - currentM) ** 2) / (2 * currentS ** 2)) * 2 - 1;
    }

    function updateTextDeathZone() {
        if (!textContainerElement || !canvas) return;
        const rect = textContainerElement.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect(); // For offset calculation

        // Calculate text box position relative to the canvas
        const textLeftRelToCanvas = rect.left - canvasRect.left;
        const textTopRelToCanvas = rect.top - canvasRect.top;

        textZone.x1 = Math.max(0, Math.floor(textLeftRelToCanvas / CELL_SIZE));
        textZone.y1 = Math.max(0, Math.floor(textTopRelToCanvas / CELL_SIZE));
        textZone.x2 = Math.min(gridWidth, Math.ceil((textLeftRelToCanvas + rect.width) / CELL_SIZE));
        textZone.y2 = Math.min(gridHeight, Math.ceil((textTopRelToCanvas + rect.height) / CELL_SIZE));
        console.log('Text death zone (grid coords):', textZone);
    }

    function initializeGrid() {
        grid = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(0));
        nextGrid = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(0));
        
        const tEdgeInit = time * RAGGED_EDGE_TIME_NOISE_SCALE; // Use current time for initial raggedness

        for (let yCell = 0; yCell < gridHeight; yCell++) {
            for (let xCell = 0; xCell < gridWidth; xCell++) {
                let isInsideInitialRaggedZone = false;
                if (textZone.x2 > textZone.x1 && textZone.y2 > textZone.y1) { // Check if textZone is valid
                    // Calculate perturbed edges for this cell at current time
                    const noiseX1 = edgeNoise(xCell * RAGGED_EDGE_NOISE_SCALE, yCell * RAGGED_EDGE_NOISE_SCALE + 10, tEdgeInit) * RAGGED_EDGE_NOISE_MAGNITUDE;
                    const noiseX2 = edgeNoise(xCell * RAGGED_EDGE_NOISE_SCALE, yCell * RAGGED_EDGE_NOISE_SCALE + 20, tEdgeInit) * RAGGED_EDGE_NOISE_MAGNITUDE;
                    const noiseY1 = edgeNoise(xCell * RAGGED_EDGE_NOISE_SCALE + 30, yCell * RAGGED_EDGE_NOISE_SCALE, tEdgeInit) * RAGGED_EDGE_NOISE_MAGNITUDE;
                    const noiseY2 = edgeNoise(xCell * RAGGED_EDGE_NOISE_SCALE + 40, yCell * RAGGED_EDGE_NOISE_SCALE, tEdgeInit) * RAGGED_EDGE_NOISE_MAGNITUDE;

                    const perturbedX1 = textZone.x1 + noiseX1;
                    const perturbedX2 = textZone.x2 + noiseX2;
                    const perturbedY1 = textZone.y1 + noiseY1;
                    const perturbedY2 = textZone.y2 + noiseY2;

                    if (xCell >= perturbedX1 && xCell < perturbedX2 &&
                        yCell >= perturbedY1 && yCell < perturbedY2) {
                        isInsideInitialRaggedZone = true;
                    }
                }

                if (isInsideInitialRaggedZone) {
                    grid[yCell][xCell] = 0; // Initialize as cleared if inside ragged zone
                } else {
                    grid[yCell][xCell] = Math.random(); // Random initial state otherwise
                }
            }
        }
        updateTextDeathZone(); // Initial calculation of the rectangular textZone
    }

    function resizeCanvas() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        gridWidth = Math.ceil(canvas.width / CELL_SIZE);
        gridHeight = Math.ceil(canvas.height / CELL_SIZE);
        console.log(`Canvas resized: ${canvas.width}x${canvas.height}, Grid: ${gridWidth}x${gridHeight}`);
        
        if (gridWidth > 0 && gridHeight > 0) {
            updateActiveLeniaParams(); 
            createKernel();         
            updateTextDeathZone(); // Update text death zone before initializing grid to avoid seeding in the text zone
            initializeGrid();
        } else {
            grid = []; nextGrid =[];
        }
    }

    window.addEventListener('resize', resizeCanvas);
    // Initial size setting & grid initialization done by calling resizeCanvas()
    

    function updateGrid() {
        if (!grid || grid.length === 0) return;

        const activeWind = currentWind && Date.now() < currentWind.endTime ? currentWind : null;
        const K_RADIUS = KERNEL_PRESETS[SELECTED_KERNEL_TYPE].KERNEL_RADIUS;

        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                let potential = 0;
                for (let i = -K_RADIUS; i <= K_RADIUS; i++) {
                    for (let j = -K_RADIUS; j <= K_RADIUS; j++) {
                        const ny = (y + i + gridHeight) % gridHeight;
                        const nx = (x + j + gridWidth) % gridWidth;
                        potential += grid[ny][nx] * kernel[i + K_RADIUS][j + K_RADIUS];
                    }
                }
                const currentVal = grid[y][x];
                const growth = growthFunction(potential);
                let newVal = currentVal + currentDT * growth;

                if (activeWind) {
                    const upwindX = (x - activeWind.dx + gridWidth) % gridWidth;
                    const upwindY = (y - activeWind.dy + gridHeight) % gridHeight;
                    const upwindValue = grid[upwindY][upwindX];
                    newVal += upwindValue * activeWind.strength;
                }

                newVal = Math.max(0, Math.min(1, newVal));
                nextGrid[y][x] = newVal;
            }
        }
        [grid, nextGrid] = [nextGrid, grid];

        // Clear cells in the text zone with animated ragged edges
        if (textZone.x2 > textZone.x1 && textZone.y2 > textZone.y1) {
            const startX = Math.max(0, textZone.x1 - RAGGED_EDGE_PADDING);
            const endX = Math.min(gridWidth, textZone.x2 + RAGGED_EDGE_PADDING);
            const startY = Math.max(0, textZone.y1 - RAGGED_EDGE_PADDING);
            const endY = Math.min(gridHeight, textZone.y2 + RAGGED_EDGE_PADDING);

            for (let yCell = startY; yCell < endY; yCell++) {
                for (let xCell = startX; xCell < endX; xCell++) {
                    const t = time * RAGGED_EDGE_TIME_NOISE_SCALE;
                    // Perturb each edge independently using animated noise
                    const noiseX1 = edgeNoise(xCell * RAGGED_EDGE_NOISE_SCALE, yCell * RAGGED_EDGE_NOISE_SCALE + 10, t) * RAGGED_EDGE_NOISE_MAGNITUDE;
                    const noiseX2 = edgeNoise(xCell * RAGGED_EDGE_NOISE_SCALE, yCell * RAGGED_EDGE_NOISE_SCALE + 20, t) * RAGGED_EDGE_NOISE_MAGNITUDE;
                    const noiseY1 = edgeNoise(xCell * RAGGED_EDGE_NOISE_SCALE + 30, yCell * RAGGED_EDGE_NOISE_SCALE, t) * RAGGED_EDGE_NOISE_MAGNITUDE;
                    const noiseY2 = edgeNoise(xCell * RAGGED_EDGE_NOISE_SCALE + 40, yCell * RAGGED_EDGE_NOISE_SCALE, t) * RAGGED_EDGE_NOISE_MAGNITUDE;

                    const perturbedX1 = textZone.x1 + noiseX1;
                    const perturbedX2 = textZone.x2 + noiseX2;
                    const perturbedY1 = textZone.y1 + noiseY1;
                    const perturbedY2 = textZone.y2 + noiseY2;

                    // Check if the cell is within the perturbed, ragged rectangle
                    if (xCell >= perturbedX1 && xCell < perturbedX2 &&
                        yCell >= perturbedY1 && yCell < perturbedY2) {
                        if (Math.random() > currentTextZoneSurvivalChance) { 
                            grid[yCell][xCell] = 0;
                        }
                    }
                }
            }
        }
    }

    function drawGrid() {
        if (!grid || grid.length === 0 || !ctx) return;
        ctx.fillStyle = 'hsl(210, 15%, 97%)'; // Overall canvas background
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let currentEffectStrength = 0;
        if (mouseEffectCenter && Date.now() - lastMouseMoveInTextZoneTime < MOUSE_EFFECT_DURATION) {
            currentEffectStrength = 1.0 - (Date.now() - lastMouseMoveInTextZoneTime) / MOUSE_EFFECT_DURATION;
        } else {
            mouseEffectCenter = null; // Reset if effect has expired
        }

        const hueStart = 200; // For active cells (Lenia patterns)
        const hueEnd = 230;   // For active cells (Lenia patterns)

        // Base HSL for inactive text zone cells (the light gray Perlin noise background)
        const baseHueTextZone = 210;
        const baseSaturationTextZone = 10;
        const baseLightnessTextZone = 94;
        const lightnessNoiseRange = 10; 
        const hueNoiseRange = 20; 
        // const baseHueTextZone = 210;
        // const baseSaturationTextZone = 93.70;
        // const baseLightnessTextZone = 85.60;
        // const lightnessNoiseRange = 10; // Total range for lightness noise
        // const hueNoiseRange = 20; // Total range for hue noise

        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                const value = grid[y][x]; // Value from 0 to 1 (Lenia cell state)

                if (value > 0.01) { // Active Lenia cell - draw on top
                    const hue = hueStart + (hueEnd - hueStart) * value;
                    const saturation = 5 + Math.floor(value * 30);
                    const lightness = 90 - Math.floor(value * 20);
                    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                } else { // Inactive cell - apply Perlin noise background everywhere
                    // Calculate base Perlin noise for the background pattern
                    const n = backgroundNoise(x * noiseScale, y * noiseScale, time * timeNoiseScale);
                    const normalizedNoise = (n + 1) / 2; 

                    const hueVariation = (normalizedNoise - 0.5) * hueNoiseRange;
                    const noisyHue = Math.max(0, Math.min(360, baseHueTextZone + hueVariation));

                    const lightnessVariation = (normalizedNoise - 0.5) * lightnessNoiseRange;
                    let noisyLightness = Math.max(0, Math.min(100, baseLightnessTextZone + lightnessVariation));

                    // Check if current cell (x,y) is within the ANIMATED RAGGED text zone boundary
                    // to apply mouse effect only there.
                    let isInsideRaggedZoneForMouseEffect = false;
                    if (textZone.x2 > textZone.x1 && textZone.y2 > textZone.y1) { 
                        const tEdge = time * RAGGED_EDGE_TIME_NOISE_SCALE;
                        const noiseX1 = edgeNoise(x * RAGGED_EDGE_NOISE_SCALE, y * RAGGED_EDGE_NOISE_SCALE + 10, tEdge) * RAGGED_EDGE_NOISE_MAGNITUDE;
                        const noiseX2 = edgeNoise(x * RAGGED_EDGE_NOISE_SCALE, y * RAGGED_EDGE_NOISE_SCALE + 20, tEdge) * RAGGED_EDGE_NOISE_MAGNITUDE;
                        const noiseY1 = edgeNoise(x * RAGGED_EDGE_NOISE_SCALE + 30, y * RAGGED_EDGE_NOISE_SCALE, tEdge) * RAGGED_EDGE_NOISE_MAGNITUDE;
                        const noiseY2 = edgeNoise(x * RAGGED_EDGE_NOISE_SCALE + 40, y * RAGGED_EDGE_NOISE_SCALE, tEdge) * RAGGED_EDGE_NOISE_MAGNITUDE;

                        const perturbedX1 = textZone.x1 + noiseX1;
                        const perturbedX2 = textZone.x2 + noiseX2;
                        const perturbedY1 = textZone.y1 + noiseY1;
                        const perturbedY2 = textZone.y2 + noiseY2;
                        if (x >= perturbedX1 && x < perturbedX2 && y >= perturbedY1 && y < perturbedY2) {
                            isInsideRaggedZoneForMouseEffect = true;
                        }
                    }

                    // Apply direct mouse effect to lightness if inside the ragged zone
                    if (isInsideRaggedZoneForMouseEffect && mouseEffectCenter && currentEffectStrength > 0) {
                        const dxMouse = x - mouseEffectCenter.x;
                        const dyMouse = y - mouseEffectCenter.y;
                        const distSqMouse = dxMouse * dxMouse + dyMouse * dyMouse;

                        if (distSqMouse < MOUSE_EFFECT_RADIUS * MOUSE_EFFECT_RADIUS) {
                            const distMouse = Math.sqrt(distSqMouse);
                            const interactionFactor = (1.0 - distMouse / MOUSE_EFFECT_RADIUS) * currentEffectStrength;
                            const lightnessShift = interactionFactor * MOUSE_EFFECT_SHIFT_MAGNITUDE;
                            noisyLightness += lightnessShift;
                            noisyLightness = Math.max(0, Math.min(100, noisyLightness));
                        }
                    }
                    
                    ctx.fillStyle = `hsl(${noisyHue}, ${baseSaturationTextZone}%, ${noisyLightness}%)`;
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
        }
    }

    function handleMouseMove(event) {
        if (!grid || grid.length === 0) return;
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        const gridX = Math.floor(mouseX / CELL_SIZE);
        const gridY = Math.floor(mouseY / CELL_SIZE);

        // Update for text zone background effect
        if (textZone && textZone.x1 !== undefined &&
            gridX >= textZone.x1 && gridX < textZone.x2 &&
            gridY >= textZone.y1 && gridY < textZone.y2) {
            mouseEffectCenter = { x: gridX, y: gridY };
            lastMouseMoveInTextZoneTime = Date.now();
        }

        // Original interaction: Kill cells in radius (affects automata layer)
        for (let i = -INTERACTION_RADIUS; i <= INTERACTION_RADIUS; i++) {
            for (let j = -INTERACTION_RADIUS; j <= INTERACTION_RADIUS; j++) {
                if (i*i + j*j > INTERACTION_RADIUS * INTERACTION_RADIUS) continue; // Circular area

                const affectX = (gridX + j + gridWidth) % gridWidth;
                const affectY = (gridY + i + gridHeight) % gridHeight;
                
                if (affectX >= 0 && affectX < gridWidth && affectY >= 0 && affectY < gridHeight) {
                    grid[affectY][affectX] = 0; // Kill cells in radius
                }
            }
        }
    }
    canvas.addEventListener('mousemove', handleMouseMove);

    let lastUpdateTime = 0;
    const updateInterval = 1; // ms, faster updates for smoother Lenia-like feel

    function startWindEvent() {
        const direction = WIND_DIRECTIONS[Math.floor(Math.random() * WIND_DIRECTIONS.length)];
        const duration = WIND_EVENT_MIN_DURATION + Math.random() * (WIND_EVENT_MAX_DURATION - WIND_EVENT_MIN_DURATION);
        currentWind = {
            dx: direction.dx,
            dy: direction.dy,
            strength: WIND_STRENGTH,
            endTime: Date.now() + duration
        };
        console.log(`Wind started: dir (${currentWind.dx},${currentWind.dy}), duration ${duration.toFixed(0)}ms`);
        
        // Schedule end of this wind and then the next wind event
        windTimeoutId = setTimeout(() => {
            console.log('Wind ended.');
            currentWind = null;
            scheduleNextWindEvent(); 
        }, duration);
    }

    function scheduleNextWindEvent() {
        if (windTimeoutId) clearTimeout(windTimeoutId); // Clear previous timeout if any
        const nextInterval = WIND_EVENT_MIN_INTERVAL + Math.random() * (WIND_EVENT_MAX_INTERVAL - WIND_EVENT_MIN_INTERVAL);
        windTimeoutId = setTimeout(startWindEvent, nextInterval);
        console.log(`Next wind event scheduled in ${nextInterval.toFixed(0)}ms`);
    }

    function animationLoop(timestamp) {
        if (gridWidth > 0 && gridHeight > 0) { // Ensure grid is initialized
            if (timestamp - lastUpdateTime > updateInterval) {
                updateGrid();
                lastUpdateTime = timestamp;
            }
            time++; // Increment time for Perlin noise animation
            drawGrid();
        }
        requestAnimationFrame(animationLoop);
    }

    // Initial setup
    resizeCanvas();
    console.log('Continuous automata with wind and text zone loaded.');
    scheduleNextWindEvent();
    requestAnimationFrame(animationLoop);

    // --- Spacebar to switch kernel ---
    window.addEventListener('keydown', (event) => {
        if (event.code === 'Space') {
            event.preventDefault(); // Prevent page scrolling
            if (availableKernelTypes.length > 0) {
                let newKernelType = SELECTED_KERNEL_TYPE;
                if (availableKernelTypes.length > 1) {
                    while (newKernelType === SELECTED_KERNEL_TYPE) {
                        newKernelType = availableKernelTypes[Math.floor(Math.random() * availableKernelTypes.length)];
                    }
                } else {
                    // Reinitialize if only one kernel
                    newKernelType = availableKernelTypes[0]; 
                }
                SELECTED_KERNEL_TYPE = newKernelType;
                console.log(`Spacebar pressed: Switching to kernel -> ${SELECTED_KERNEL_TYPE}`);
                resizeCanvas();
            }
        }
    });
}); 
