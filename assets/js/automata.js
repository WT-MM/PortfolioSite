document.addEventListener('DOMContentLoaded', () => {
    const textElement = document.querySelector('.text-preload');
    if (textElement) {
        requestAnimationFrame(() => {
            textElement.classList.add('text-loaded');
        });
    }

    const canvas = document.getElementById('automataCanvas');
    if (!canvas) {
        console.error('Canvas element not found!');
        return;
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error('2D context not available.');
        return;
    }

    const textContainerElement = document.querySelector('.text'); // Get the .text element
    let textZone = { x1: 0, y1: 0, x2: 0, y2: 0 }; // In grid coordinates

    let CELL_SIZE = 15;
    let gridWidth, gridHeight;
    let grid, nextGrid;

    let currentM, currentS, currentDT;
    let currentTextZoneSurvivalChance;

    const KERNEL_PRESETS = {
        "gaussian_soft": { // stripy
            M: 0.25,  // Mean of the growth function's peak (center of the fertile potential range for cell growth)
            S: 0.035, // Standard deviation of the growth function's peak (width of the fertile range)
            DT: 0.01, // Time step for simulation (how much a cell's value changes per update based on growth)
            KERNEL_RADIUS: 3, // Radius of the convolution kernel (neighborhood size; kernel matrix is (2*R+1)x(2*R+1))
            TEXT_ZONE_SURVIVAL_CHANCE: 0.97 // Chance (0-1) for cells in the text overlay area to survive clearing each step
        },
        "gaussian_sharp": { // brick wall
            M: 0.1,   // Mean for growth peak
            S: 0.01,  // Std. dev. for growth peak (sharper peak)
            DT: 0.015,// Time step
            KERNEL_RADIUS: 10, // Kernel radius
            TEXT_ZONE_SURVIVAL_CHANCE: 0.90 // Text zone survival chance
        },
        "sombrero": { // organic
            M: 0.1,   // Mean for growth peak
            S: 0.25,  // Std. dev. for growth peak (wider peak for sombrero often works well)
            DT: 0.01, // Time step
            KERNEL_RADIUS: 3, // Kernel radius
            TEXT_ZONE_SURVIVAL_CHANCE: 0.4 // Text zone survival chance
        }
    };

    const INTERACTION_RADIUS = 3;
    const availableKernelTypes = Object.keys(KERNEL_PRESETS);
    let SELECTED_KERNEL_TYPE = availableKernelTypes[Math.floor(Math.random() * availableKernelTypes.length)];

    // --- Wind Parameters ---
    const WIND_DIRECTIONS = [ // Possible directions for wind events {dx: change in x, dy: change in y}
        { dx: 1, dy: 0 },  // East
        { dx: -1, dy: 0 }, // West
        { dx: 0, dy: 1 },  // South
        { dx: 0, dy: -1 }  // North
    ];
    let currentWind = null; // Stores active wind: { dx, dy, strength, endTime }
    const WIND_STRENGTH = 0.005;            // Factor determining how much an upwind cell's value influences its downwind neighbor.
    const WIND_EVENT_MIN_INTERVAL = 100;  // Minimum time (ms) between the end of one wind event and the start of the next.
    const WIND_EVENT_MAX_INTERVAL = 200;  // Maximum time (ms) between the end of one wind event and the start of the next.
    const WIND_EVENT_MIN_DURATION = 500;  // Minimum duration (ms) a single wind event can last.
    const WIND_EVENT_MAX_DURATION = 1000; // Maximum duration (ms) a single wind event can last.
    let windTimeoutId = null;
    let kernel; // Convolution kernel matrix, generated by createKernel()

    function updateActiveLeniaParams() {
        const preset = KERNEL_PRESETS[SELECTED_KERNEL_TYPE];
        if (!preset) {
            console.error(`Preset for kernel type ${SELECTED_KERNEL_TYPE} not found! Using defaults.`);
            currentM = 0.15;
            currentS = 0.015;
            currentDT = 0.1;
            currentTextZoneSurvivalChance = 0.9;
            return;
        }
        currentM = preset.M;
        currentS = preset.S;
        currentDT = preset.DT;
        currentTextZoneSurvivalChance = preset.TEXT_ZONE_SURVIVAL_CHANCE;
        console.log(`Activated Lenia params for ${SELECTED_KERNEL_TYPE}: M=${currentM}, S=${currentS}, DT=${currentDT}, K_RADIUS=${preset.KERNEL_RADIUS}, TZ_Survival=${currentTextZoneSurvivalChance}`);
    }

    function createKernel() {
        const preset = KERNEL_PRESETS[SELECTED_KERNEL_TYPE];
        const K_RADIUS = preset.KERNEL_RADIUS;
        const size = 2 * K_RADIUS + 1;
        kernel = Array(size).fill(null).map(() => Array(size).fill(0));
        let sum = 0;

        console.log(`Creating kernel: ${SELECTED_KERNEL_TYPE} with K_RADIUS: ${K_RADIUS}`);

        for (let i = -K_RADIUS; i <= K_RADIUS; i++) {
            for (let j = -K_RADIUS; j <= K_RADIUS; j++) {
                const distSq = i * i + j * j;
                let val = 0;

                if (SELECTED_KERNEL_TYPE === "gaussian_soft") {
                    const sigma = K_RADIUS / 2;
                    val = Math.exp(-distSq / (2 * sigma * sigma));
                } else if (SELECTED_KERNEL_TYPE === "gaussian_sharp") {
                    const sigma = K_RADIUS / 4;
                    val = Math.exp(-distSq / (2 * sigma * sigma));
                } else if (SELECTED_KERNEL_TYPE === "sombrero") {
                    const sigma1 = K_RADIUS / 3;
                    const sigma2 = K_RADIUS * 0.8;
                    const val1 = Math.exp(-distSq / (2 * sigma1 * sigma1));
                    const val2 = Math.exp(-distSq / (2 * sigma2 * sigma2));
                    val = val1 - 0.7 * val2;
                }
                
                kernel[i + K_RADIUS][j + K_RADIUS] = val;
                sum += val;
            }
        }

        if (sum !== 0) {
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    kernel[i][j] /= sum;
                }
            }
        } else {
            if (kernel[K_RADIUS] && kernel[K_RADIUS][K_RADIUS] !== undefined) {
                 kernel[K_RADIUS][K_RADIUS] = 1;
                 console.warn("Kernel sum was 0, fallback to center = 1. Check kernel parameters.");
            }
        }
    }

    function growthFunction(u) {
        return Math.exp(-((u - currentM) ** 2) / (2 * currentS ** 2)) * 2 - 1;
    }

    function updateTextDeathZone() {
        if (!textContainerElement || !canvas) return;
        const rect = textContainerElement.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect(); // For offset calculation

        // Calculate text box position relative to the canvas
        const textLeftRelToCanvas = rect.left - canvasRect.left;
        const textTopRelToCanvas = rect.top - canvasRect.top;

        textZone.x1 = Math.max(0, Math.floor(textLeftRelToCanvas / CELL_SIZE));
        textZone.y1 = Math.max(0, Math.floor(textTopRelToCanvas / CELL_SIZE));
        textZone.x2 = Math.min(gridWidth, Math.ceil((textLeftRelToCanvas + rect.width) / CELL_SIZE));
        textZone.y2 = Math.min(gridHeight, Math.ceil((textTopRelToCanvas + rect.height) / CELL_SIZE));
        console.log('Text death zone (grid coords):', textZone);
    }

    function initializeGrid() {
        grid = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(0));
        nextGrid = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(0));
        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                grid[y][x] = Math.random(); // Random initial state (0 to 1)
            }
        }
        updateTextDeathZone(); // Initial calculation
    }

    function resizeCanvas() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        gridWidth = Math.floor(canvas.width / CELL_SIZE);
        gridHeight = Math.floor(canvas.height / CELL_SIZE);
        console.log(`Canvas resized: ${canvas.width}x${canvas.height}, Grid: ${gridWidth}x${gridHeight}`);
        
        if (gridWidth > 0 && gridHeight > 0) {
            updateActiveLeniaParams(); // Load M, S, DT for the selected kernel type
            createKernel();         
            initializeGrid();       
            updateTextDeathZone(); 
        } else {
            grid = []; nextGrid =[];
        }
    }

    window.addEventListener('resize', resizeCanvas);
    // Initial size setting & grid initialization done by calling resizeCanvas()
    

    function updateGrid() {
        if (!grid || grid.length === 0) return;

        const activeWind = currentWind && Date.now() < currentWind.endTime ? currentWind : null;
        const K_RADIUS = KERNEL_PRESETS[SELECTED_KERNEL_TYPE].KERNEL_RADIUS;

        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                let potential = 0;
                for (let i = -K_RADIUS; i <= K_RADIUS; i++) {
                    for (let j = -K_RADIUS; j <= K_RADIUS; j++) {
                        const ny = (y + i + gridHeight) % gridHeight;
                        const nx = (x + j + gridWidth) % gridWidth;
                        potential += grid[ny][nx] * kernel[i + K_RADIUS][j + K_RADIUS];
                    }
                }
                const currentVal = grid[y][x];
                const growth = growthFunction(potential);
                let newVal = currentVal + currentDT * growth;

                if (activeWind) {
                    const upwindX = (x - activeWind.dx + gridWidth) % gridWidth;
                    const upwindY = (y - activeWind.dy + gridHeight) % gridHeight;
                    const upwindValue = grid[upwindY][upwindX];
                    newVal += upwindValue * activeWind.strength;
                }

                newVal = Math.max(0, Math.min(1, newVal));
                nextGrid[y][x] = newVal;
            }
        }
        [grid, nextGrid] = [nextGrid, grid];

        if (textZone.x2 > textZone.x1 && textZone.y2 > textZone.y1) {
            for (let y = textZone.y1; y < textZone.y2; y++) {
                for (let x = textZone.x1; x < textZone.x2; x++) {
                    if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                        if (Math.random() > currentTextZoneSurvivalChance) { 
                            grid[y][x] = 0;
                        }
                    }
                }
            }
        }
    }

    function drawGrid() {
        if (!grid || grid.length === 0 || !ctx) return;
        ctx.fillStyle = 'hsl(210, 15%, 97%)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const hueStart = 200;
        const hueEnd = 230;

        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                const value = grid[y][x]; // Value from 0 to 1
                if (value > 0.01) { 
                    // Interpolate hue based on value for subtle shifts
                    const hue = hueStart + (hueEnd - hueStart) * value;
                    
                    // Saturation: increases with value, but stays desaturated
                    const saturation = 5 + Math.floor(value * 30); // 5% to 35%
                    
                    // Lightness: decreases with value to make active cells more prominent (but still light)
                    const lightness = 90 - Math.floor(value * 20);

                    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`; 
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
        }
    }

    function handleMouseMove(event) {
        if (!grid || grid.length === 0) return;
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        const gridX = Math.floor(mouseX / CELL_SIZE);
        const gridY = Math.floor(mouseY / CELL_SIZE);

        for (let i = -INTERACTION_RADIUS; i <= INTERACTION_RADIUS; i++) {
            for (let j = -INTERACTION_RADIUS; j <= INTERACTION_RADIUS; j++) {
                if (i*i + j*j > INTERACTION_RADIUS * INTERACTION_RADIUS) continue; // Circular area

                const affectX = (gridX + j + gridWidth) % gridWidth;
                const affectY = (gridY + i + gridHeight) % gridHeight;
                
                if (affectX >= 0 && affectX < gridWidth && affectY >= 0 && affectY < gridHeight) {
                    grid[affectY][affectX] = 0; // Kill cells in radius
                }
            }
        }
    }
    canvas.addEventListener('mousemove', handleMouseMove);

    let lastUpdateTime = 0;
    const updateInterval = 1; // ms, faster updates for smoother Lenia-like feel

    function startWindEvent() {
        const direction = WIND_DIRECTIONS[Math.floor(Math.random() * WIND_DIRECTIONS.length)];
        const duration = WIND_EVENT_MIN_DURATION + Math.random() * (WIND_EVENT_MAX_DURATION - WIND_EVENT_MIN_DURATION);
        currentWind = {
            dx: direction.dx,
            dy: direction.dy,
            strength: WIND_STRENGTH,
            endTime: Date.now() + duration
        };
        console.log(`Wind started: dir (${currentWind.dx},${currentWind.dy}), duration ${duration.toFixed(0)}ms`);
        
        // Schedule end of this wind and then the next wind event
        windTimeoutId = setTimeout(() => {
            console.log('Wind ended.');
            currentWind = null;
            scheduleNextWindEvent(); 
        }, duration);
    }

    function scheduleNextWindEvent() {
        if (windTimeoutId) clearTimeout(windTimeoutId); // Clear previous timeout if any
        const nextInterval = WIND_EVENT_MIN_INTERVAL + Math.random() * (WIND_EVENT_MAX_INTERVAL - WIND_EVENT_MIN_INTERVAL);
        windTimeoutId = setTimeout(startWindEvent, nextInterval);
        console.log(`Next wind event scheduled in ${nextInterval.toFixed(0)}ms`);
    }

    function animationLoop(timestamp) {
        if (gridWidth > 0 && gridHeight > 0) { // Ensure grid is initialized
            if (timestamp - lastUpdateTime > updateInterval) {
                updateGrid();
                lastUpdateTime = timestamp;
            }
            drawGrid();
        }
        requestAnimationFrame(animationLoop);
    }

    // Initial setup
    resizeCanvas();
    console.log('Continuous automata with wind and text zone loaded.');
    scheduleNextWindEvent();
    requestAnimationFrame(animationLoop);

    // --- Spacebar to switch kernel ---
    window.addEventListener('keydown', (event) => {
        if (event.code === 'Space') {
            event.preventDefault(); // Prevent page scrolling
            if (availableKernelTypes.length > 0) {
                let newKernelType = SELECTED_KERNEL_TYPE;
                if (availableKernelTypes.length > 1) {
                    while (newKernelType === SELECTED_KERNEL_TYPE) {
                        newKernelType = availableKernelTypes[Math.floor(Math.random() * availableKernelTypes.length)];
                    }
                } else {
                    // Reinitialize if only one kernel
                    newKernelType = availableKernelTypes[0]; 
                }
                SELECTED_KERNEL_TYPE = newKernelType;
                console.log(`Spacebar pressed: Switching to kernel -> ${SELECTED_KERNEL_TYPE}`);
                resizeCanvas();
            }
        }
    });
}); 
